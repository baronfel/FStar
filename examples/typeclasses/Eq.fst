module Eq

open FStar.Tactics.Typeclasses

(* A class for decidable equality *)
class deq a = {
  eq    : a -> a -> bool;
  eq_ok : (x:a) -> (y:a) -> Lemma (eq x y <==> x == y) // hacking a dependent record... no concrete syntax
}

(* These methods are generated by the splice *)
(* [@tcnorm] let eq_ok (#a:Type) [|d : deq a|] = d.eq_ok *)
(* [@tcnorm] let eq    (#a:Type) [|d : deq a|] = d.eq *)

(* A way to get `deq a` for any `a : eqtype` *)
let eq_instance_of_eqtype (#a:eqtype) : deq a =
  Mkdeq (fun x y -> x = y) (fun x y -> ())

(* Two concrete instances *)
instance _ : deq int = eq_instance_of_eqtype
instance _ : deq bool = eq_instance_of_eqtype
instance _ : deq string = eq_instance_of_eqtype

let rec eqList [|deq 'a|] (xs ys : list 'a) : Tot (b:bool{b <==> xs == ys}) =
  match xs, ys with
  | [], [] -> true
  | x::xs, y::ys -> eq_ok x y; eq x y && eqList xs ys
  | _, _ -> false

(* Parametric instances *)
instance eq_list (_ : deq 'a) : deq (list 'a) =
  Mkdeq eqList (fun x y -> ())

instance eq_pair (_ : deq 'a) (_ : deq 'b) : deq ('a * 'b) =
  Mkdeq (fun (a,b) (c,d) -> eq a c && eq b d)
        (fun (a,b) (c,d) -> eq_ok a c; eq_ok b d)

(* A few tests *)
let _ = assert (eq 1 1)
let _ = assert (not (eq 1 2))

let _ = assert (eq true true)
let _ = assert (not (eq true false))

let _ = assert (eq [1;2] [1;2])
let _ = assert (not (eq [2;1] [1;2]))

let _ = assert (eq (1, "A") (1, "A"))
let _ = assert (not (eq (1, "A") (1, "B")))
let _ = assert (not (eq (2, "A") (1, "B")))
let _ = assert (not (eq (2, "A") (1, "A")))
