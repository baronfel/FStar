module Num

open FStar.Tactics.Typeclasses
open Eq
open Add

(* Numeric class, including superclasses for decidable equality
 * and a monoid, extended with a minus operation. *)
class num a = {
    eq_super  : deq a;
    add_super : additive a;
    minus     : a -> a -> a;
}

(* These methods are generated by the splice *)
(* [@tcnorm] let minus (#a:Type) [|d : num a|] = d.minus *)

(* Superclass projectors! Should also be autogenerated. Note the `instance` attribute,
 * differently from the methods, since these participate in the search. *)
instance num_eq  (d : num 'a) : deq 'a = d.eq_super
instance add_num (d : num 'a) : additive 'a = d.add_super

let mknum (#a:Type) [|deq a|] [|additive a|] (f : a -> a -> a) : num a =
  { eq_super  = solve;
    add_super = solve;
    minus     = f; }

instance num_int : num int = mknum (fun x y -> x - y)

instance num_bool : num bool = mknum (fun x y -> x && not y)
